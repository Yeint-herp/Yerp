#ifndef TYPE_TRAITS_KTL
#define TYPE_TRAITS_KTL

namespace ktl {
    
template<class T, T v>
struct integral_constant {
    static constexpr T                    value = v;
    using                                  value_type = T;
    using                                  type = integral_constant;
    constexpr operator value_type() const noexcept { return value; }
};

using true_type  = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

template<bool B, class T = void>
struct enable_if {};

template<class T>
struct enable_if<true, T> { using type = T; };

template<bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type;

template<bool B, class T, class F>
struct conditional { using type = T; };

template<class T, class F>
struct conditional<false, T, F> { using type = F; };

template<bool B, class T, class F>
using conditional_t = typename conditional<B, T, F>::type;

template<class...>
using void_t = void;

template<class T, class U>
struct is_same : false_type {};

template<class T>
struct is_same<T, T> : true_type {};

template<class T, class U>
inline constexpr bool is_same_v = is_same<T, U>::value;

template<class T>
struct remove_const { using type = T; };

template<class T>
struct remove_const<const T> { using type = T; };

template<class T>
struct remove_volatile { using type = T; };

template<class T>
struct remove_volatile<volatile T> { using type = T; };

template<class T>
struct remove_cv {
    using type = typename remove_volatile<typename remove_const<T>::type>::type;
};

template<class T>
using remove_cv_t = typename remove_cv<T>::type;

template<class T>
struct remove_reference { using type = T; };

template<class T>
struct remove_reference<T&> { using type = T; };

template<class T>
struct remove_reference<T&&> { using type = T; };

template<class T>
using remove_reference_t = typename remove_reference<T>::type;

template<class T>
struct add_lvalue_reference { using type = T&; };

template<class T>
struct add_rvalue_reference { using type = T&&; };

template<class T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template<class T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

template<class T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;

template<class T>
struct is_const : false_type {};

template<class T>
struct is_const<const T> : true_type {};

template<class T>
inline constexpr bool is_const_v = is_const<T>::value;

template<class T>
struct is_volatile : false_type {};

template<class T>
struct is_volatile<volatile T> : true_type {};

template<class T>
inline constexpr bool is_volatile_v = is_volatile<T>::value;

template<class T>
struct is_lvalue_reference : false_type {};

template<class T>
struct is_lvalue_reference<T&> : true_type {};

template<class T>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;

template<class T>
struct is_rvalue_reference : false_type {};

template<class T>
struct is_rvalue_reference<T&&> : true_type {};

template<class T>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

template<class T>
struct is_reference : integral_constant<bool,
    is_lvalue_reference<T>::value || is_rvalue_reference<T>::value> {};

template<class T>
inline constexpr bool is_reference_v = is_reference<T>::value;

template<class T>
struct is_void : false_type {};

template<>
struct is_void<void> : true_type {};

template<class T>
inline constexpr bool is_void_v = is_void<T>::value;

template<class T>
struct is_null_pointer : false_type {};

template<>
struct is_null_pointer<decltype(nullptr)> : true_type {};

template<class T>
inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

template<class T>
struct is_integral : false_type {};

template<> struct is_integral<bool>               : true_type {};
template<> struct is_integral<char>               : true_type {};
template<> struct is_integral<signed char>        : true_type {};
template<> struct is_integral<unsigned char>      : true_type {};
template<> struct is_integral<wchar_t>            : true_type {};
template<> struct is_integral<short>              : true_type {};
template<> struct is_integral<unsigned short>     : true_type {};
template<> struct is_integral<int>                : true_type {};
template<> struct is_integral<unsigned int>       : true_type {};
template<> struct is_integral<long>               : true_type {};
template<> struct is_integral<unsigned long>      : true_type {};
template<> struct is_integral<long long>          : true_type {};
template<> struct is_integral<unsigned long long> : true_type {};

template<class T>
inline constexpr bool is_integral_v = is_integral<T>::value;

template<class T>
struct is_floating_point : false_type {};

template<> struct is_floating_point<float>       : true_type {};
template<> struct is_floating_point<double>      : true_type {};
template<> struct is_floating_point<long double> : true_type {};

template<class T>
inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

template<class T>
struct is_arithmetic : integral_constant<bool,
    is_integral<T>::value || is_floating_point<T>::value> {};

template<class T>
inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;

template<class T>
struct is_signed : integral_constant<bool,
    is_integral<T>::value && (T)-1 < (T)0> {};

template<class T>
inline constexpr bool is_signed_v = is_signed<T>::value;

template<class T>
struct is_unsigned : integral_constant<bool,
    is_integral<T>::value && (T)0 < (T)-1> {};

template<class T>
inline constexpr bool is_unsigned_v = is_unsigned<T>::value;

template<class T>
struct is_pointer : false_type {};

template<class U>
struct is_pointer<U*> : true_type {};

template<class T>
inline constexpr bool is_pointer_v = is_pointer<T>::value;

template<class T>
struct remove_pointer { using type = T; };

template<class U>
struct remove_pointer<U*> { using type = U; };

template<class T>
using remove_pointer_t = typename remove_pointer<T>::type;

template<class T>
struct add_pointer { using type = remove_reference_t<T>*; };

template<class T>
using add_pointer_t = typename add_pointer<T>::type;

template<class T>
struct is_array : false_type {};

template<class U, usize N>
struct is_array<U[N]> : true_type {};

template<class U>
struct is_array<U[]> : true_type {};

template<class T>
inline constexpr bool is_array_v = is_array<T>::value;

template<class T>
struct remove_extent { using type = T; };

template<class U, usize N>
struct remove_extent<U[N]> { using type = U; };

template<class U>
struct remove_extent<U[]> { using type = U; };

template<class T>
using remove_extent_t = typename remove_extent<T>::type;

template<class T>
struct remove_all_extents { using type = T; };

template<class U, usize N>
struct remove_all_extents<U[N]> { using type = typename remove_all_extents<U>::type; };

template<class U>
struct remove_all_extents<U[]> { using type = typename remove_all_extents<U>::type; };

template<class T>
using remove_all_extents_t = typename remove_all_extents<T>::type;

template<class T>
struct is_function : false_type {};

template<class R, class... Args>
struct is_function<R(Args...)> : true_type {};

template<class R, class... Args>
struct is_function<R(Args..., ...)> : true_type {};

template<class T>
inline constexpr bool is_function_v = is_function<T>::value;

template<class T>
struct decay {
private:
    using U = remove_cvref_t<T>;
public:
    using type = conditional_t<
        is_array<U>::value,
        remove_extent_t<U>*,
        conditional_t<
            is_function<U>::value,
            add_pointer_t<U>,
            U>>;
};

template<class T>
using decay_t = typename decay<T>::type;

template<class T>
add_rvalue_reference_t<T> declval() noexcept;

template<class From, class To>
struct is_convertible {
private:
    static true_type  test(To);
    static false_type test(...);
public:
    static constexpr bool value = decltype(test(declval<From>()))::value;
};

template<class From, class To>
inline constexpr bool is_convertible_v = is_convertible<From, To>::value;

template<class T, T... Ints>
struct integer_sequence {
    using value_type = T;
    static constexpr usize size() noexcept { return sizeof...(Ints); }
};

template<usize... Ints>
using index_sequence = integer_sequence<usize, Ints...>;

template<usize N, usize... Is>
struct make_index_sequence_impl : make_index_sequence_impl<N-1, N-1, Is...> {};

template<usize... Is>
struct make_index_sequence_impl<0, Is...> { using type = index_sequence<Is...>; };

template<usize N>
using make_index_sequence = typename make_index_sequence_impl<N>::type;

template<class... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

template<template<typename...> class Template, typename T>
struct is_instantiation_of : ktl::false_type {};

template<template<typename...> class Template, typename... Args>
struct is_instantiation_of<Template, Template<Args...>> : ktl::true_type {};

template<template<typename...> class Template, typename T>
inline constexpr bool is_instantiation_of_v = is_instantiation_of<Template, T>::value;

template<typename T>
struct is_nothrow_move_constructible
  : integral_constant<bool,
        noexcept(T(declval<T>()))> {};

template<class T>
inline constexpr bool is_nothrow_move_constructible_v =
    is_nothrow_move_constructible<T>::value;

template<typename T>
struct is_nothrow_move_assignable
  : integral_constant<bool,
        noexcept(declval<T&>() = declval<T>())> {};

template<class T>
inline constexpr bool is_nothrow_move_assignable_v =
    is_nothrow_move_assignable<T>::value;

template<typename T>
struct is_nothrow_swappable
  : integral_constant<bool,
        noexcept(swap(declval<T&>(), declval<T&>()))> {};

template<class T>
inline constexpr bool is_nothrow_swappable_v =
    is_nothrow_swappable<T>::value;

template<class T>
constexpr remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<remove_reference_t<T>&&>(t);
}

template<class T>
constexpr T&& forward(remove_reference_t<T>& t) noexcept {
    return static_cast<T&&>(t);
}

template<class T>
constexpr T&& forward(remove_reference_t<T>&& t) noexcept {
    static_assert(!is_lvalue_reference<T>::value, "ktl::forward<T>() cannot forward an rvalue as an lvalue");
    return static_cast<T&&>(t);
}

template<class T>
constexpr void swap(T& a, T& b) {
    T tmp = ktl::forward<T>(a);
    a = ktl::forward<T>(b);
    b = ktl::forward<T>(tmp);
}

} // namespace ktl

#endif //TYPE_TRAITS_KTL

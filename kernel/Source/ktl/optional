#ifndef OPTIONAL_KTL
#define OPTIONAL_KTL

#include <ktl/type_traits>
#include <ktl/initializer_list>
#include <ktl/assert>

namespace ktl {

struct nullopt_t {
    explicit constexpr nullopt_t(int) noexcept {}
};
constexpr nullopt_t nullopt{0};

struct in_place_t {
    explicit constexpr in_place_t() noexcept {}
};
constexpr in_place_t in_place{};

template<typename T>
class optional {
public:
    using value_type = T;

    constexpr optional() noexcept
      : m_engaged(false)
    {}

    constexpr optional(nullopt_t) noexcept
      : m_engaged(false)
    {}

    optional(const optional& other)
      : m_engaged(other.m_engaged)
    {
        if (m_engaged) {
            ::new (m_data) T(*other);
        }
    }

    optional(optional&& other) noexcept(ktl::is_nothrow_move_constructible<T>::value)
      : m_engaged(other.m_engaged)
    {
        if (m_engaged) {
            ::new (m_data) T(ktl::move(*other));
        }
    }

    template<typename U = T,
             typename = enable_if_t<!is_same_v<remove_cvref_t<U>, optional> &&
                                    is_convertible_v<U&&, T>>
    >
    constexpr optional(U&& v)
      : m_engaged(true)
    {
        ::new (m_data) T(forward<U>(v));
    }

    template<class... Args>
    explicit optional(in_place_t, Args&&... args)
      : m_engaged(true)
    {
        ::new (m_data) T(forward<Args>(args)...);
    }

    ~optional() {
        reset();
    }

    optional& operator=(nullopt_t) noexcept {
        reset();
        return *this;
    }

    optional& operator=(const optional& other) {
        if (this != &other) {
            if (m_engaged && other.m_engaged) {
                **this = *other;
            } else if (m_engaged) {
                reset();
            } else if (other.m_engaged) {
                emplace(*other);
            }
            // if both not engaged, do nothing
        }
        return *this;
    }

    optional& operator=(optional&& other) 
        noexcept(ktl::is_nothrow_move_constructible<T>::value &&
                 ktl::is_nothrow_move_assignable<T>::value)
    {
        if (this != &other) {
            if (m_engaged && other.m_engaged) {
                **this = ktl::move(*other);
            } else if (m_engaged) {
                reset();
            } else if (other.m_engaged) {
                emplace(ktl::move(*other));
            }
        }
        return *this;
    }

    template<typename U = T,
             typename = enable_if_t<!is_same_v<remove_cvref_t<U>, optional> &&
                                    is_convertible_v<U&&, T>>
    >
    optional& operator=(U&& v) {
        if (m_engaged) {
            **this = forward<U>(v);
        } else {
            emplace(forward<U>(v));
        }
        return *this;
    }

    constexpr T const* operator->() const noexcept {
        return reinterpret_cast<T const*>(m_data);
    }
    T* operator->() noexcept {
        return reinterpret_cast<T*>(m_data);
    }

    constexpr T const& operator*() const & {
        return *reinterpret_cast<T const*>(m_data);
    }
    T& operator*() & {
        return *reinterpret_cast<T*>(m_data);
    }

    constexpr explicit operator bool() const noexcept {
        return m_engaged;
    }

    constexpr bool has_value() const noexcept {
        return m_engaged;
    }

    T& value() & {
        assert(m_engaged && "optional::value(): no value");
        return **this;
    }
    constexpr T const& value() const & {
        assert(m_engaged && "optional::value(): no value");
        return **this;
    }

    template<typename U>
    constexpr T value_or(U&& default_value) const & {
        return m_engaged ? **this : static_cast<T>(forward<U>(default_value));
    }

    void reset() noexcept {
        if (m_engaged) {
            reinterpret_cast<T*>(m_data)->~T();
            m_engaged = false;
        }
    }

    template<class... Args>
    T& emplace(Args&&... args) {
        reset();
        ::new (m_data) T(forward<Args>(args)...);
        m_engaged = true;
        return **this;
    }

    void swap(optional& other) noexcept(
        ktl::is_nothrow_move_constructible<T>::value &&
        ktl::is_nothrow_swappable<T>::value)
    {
        if (m_engaged && other.m_engaged) {
            ktl::swap(**this, *other);
        } else if (m_engaged) {
            other.emplace(ktl::move(**this));
            reset();
        } else if (other.m_engaged) {
            emplace(ktl::move(*other));
            other.reset();
        }
    }

private:
    alignas(T) unsigned char m_data[sizeof(T)];
    bool m_engaged;
};

template<typename T>
void swap(optional<T>& a, optional<T>& b) noexcept(noexcept(a.swap(b))) {
    a.swap(b);
}

} // namespace ktl

#endif // OPTIONAL_KTL
